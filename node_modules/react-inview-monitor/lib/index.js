"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var InviewMonitor =
/*#__PURE__*/
function (_Component) {
  _inherits(InviewMonitor, _Component);

  function InviewMonitor(props) {
    var _this;

    _classCallCheck(this, InviewMonitor);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(InviewMonitor).call(this));
    _this.state = {
      className: props.classNameNotInView,
      childProps: props.childPropsNotInView
    };
    _this.onIntersectionAll = _this.onIntersectionAll.bind(_assertThisInitialized(_this));
    _this.onIntersection = _this.onIntersection.bind(_assertThisInitialized(_this));
    _this.isFirstInView = true;
    return _this;
  }

  _createClass(InviewMonitor, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (!window.IntersectionObserver) {
        console.error("react-inview-monitor found no support for IntersectionObserver.\nPerhaps use a polyfill like: https://cdn.polyfill.io/v2/polyfill.js?features=IntersectionObserver ?");
        return;
      }

      var _this$props = this.props,
          useInviewMonitor = _this$props.useInviewMonitor,
          intoViewMargin = _this$props.intoViewMargin,
          threshold = _this$props.threshold;

      if (!this._element || !useInviewMonitor || typeof useInviewMonitor === 'function' && !useInviewMonitor()) {
        return;
      }

      var options = {
        rootMargin: intoViewMargin,
        threshold: threshold
      }; // any performance benefits from trying to re-use the observer?
      // possible enhancement to add later on.

      this.observer = new window.IntersectionObserver(this.onIntersectionAll, options);
      this.observer.observe(this._element);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.observer && this.observer.disconnect();
    }
  }, {
    key: "onIntersectionAll",
    value: function onIntersectionAll(entries) {
      entries.forEach(this.onIntersection);
    }
  }, {
    key: "onIntersection",
    value: function onIntersection(entry) {
      if (entry.target !== this._element) {
        // this check only makes sense as long as we _dont_ share the same observer
        // between component instances.
        return;
      }

      var _this$props2 = this.props,
          classNameNotInView = _this$props2.classNameNotInView,
          classNameInView = _this$props2.classNameInView,
          classNameAboveView = _this$props2.classNameAboveView,
          classNameNotAboveView = _this$props2.classNameNotAboveView,
          toggleClassNameOnInView = _this$props2.toggleClassNameOnInView,
          childPropsInView = _this$props2.childPropsInView,
          childPropsNotInView = _this$props2.childPropsNotInView,
          toggleChildPropsOnInView = _this$props2.toggleChildPropsOnInView,
          onInView = _this$props2.onInView,
          onNotInView = _this$props2.onNotInView,
          repeatOnInView = _this$props2.repeatOnInView;
      var nowInView = entry.isIntersecting;
      var isFirstInView = nowInView && this.isFirstInView;

      if (isFirstInView) {
        // single out just the first inView
        this.isFirstInView = false;
      }

      var toggleClassBehavior = (typeof classNameInView === 'string' || typeof classNameAboveView === 'string') && toggleClassNameOnInView;
      var tooglePropsBehavior = childPropsInView && toggleChildPropsOnInView;
      var toggleOnInViewBehavior = (onInView || onNotInView) && repeatOnInView;
      var toggleBehavior = toggleClassBehavior || tooglePropsBehavior || toggleOnInViewBehavior;

      if (nowInView && !toggleBehavior) {
        var changes = {};
        if (typeof classNameInView === 'string') changes.className = classNameInView;
        if (childPropsInView) changes.childProps = childPropsInView;

        if (Object.keys(changes).length) {
          this.setState(changes);
        }

        if (onInView && typeof onInView === 'function') {
          onInView(entry);
        }

        this.observer.unobserve(entry.target); // is there any point trying to determine whether observer is now
        // no longer observering anything, and hence should be disconnected,
        // or is this kind of automatic?
        // To be investigated.

        return;
      }

      if (toggleBehavior) {
        // Check if we scrolled past view
        if (typeof classNameAboveView === 'string') {
          if ( // we just left the view
          !nowInView && // are we now above it (i.e. scrolled past)
          entry.boundingClientRect.top <= 0) {
            this.setState({
              className: classNameAboveView
            });
          } else {
            this.setState({
              className: classNameNotAboveView || ''
            });
          }

          return;
        } // check regular in/out of view


        if (nowInView) {
          // just entered view
          var _changes = {};
          if (toggleClassBehavior || isFirstInView) _changes.className = classNameInView;
          if (tooglePropsBehavior || isFirstInView) _changes.childProps = childPropsInView;

          if (Object.keys(_changes).length) {
            this.setState(_changes);
          }

          if (onInView && typeof onInView === 'function') {
            onInView(entry);
          }
        } else {
          // just left view
          var _changes2 = {};
          if (toggleClassBehavior) _changes2.className = classNameNotInView;
          if (tooglePropsBehavior) _changes2.childProps = childPropsNotInView;

          if (Object.keys(_changes2).length) {
            this.setState(_changes2);
          }

          if (onNotInView && typeof onNotInView === 'function') {
            onNotInView(entry);
          }
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$state = this.state,
          childProps = _this$state.childProps,
          className = _this$state.className;
      var _this$props3 = this.props,
          useInviewMonitor = _this$props3.useInviewMonitor,
          children = _this$props3.children;

      if (childProps && Object.keys(childProps).length) {
        children = _react["default"].cloneElement(children, childProps);
      }

      return _react["default"].createElement("div", {
        className: className,
        ref: function ref(e) {
          if (e) {
            _this2._element = e;
          }
        }
      }, children);
    }
  }]);

  return InviewMonitor;
}(_react.Component);

InviewMonitor.propTypes = {
  // common usage: animate classes in onScrollIntoView, to trigger fade in etc animations
  classNameInView: _propTypes["default"].string,
  // can be used to hide elements to be animated in.
  classNameNotInView: _propTypes["default"].string,
  // can be used as a trigger for "scrolled past view", f.e. for sticky headers
  classNameAboveView: _propTypes["default"].string,
  classNameNotAboveView: _propTypes["default"].string,
  // can be used to switch classes on/off, for fixed navigation based on scroll point, etc
  toggleClassNameOnInView: _propTypes["default"].bool,
  // another use for the InviewMonitor is to start passing a prop into an element
  // only when it has been scrolled into view; f.e. to autoplay a video.
  childPropsInView: _propTypes["default"].object,
  childPropsNotInView: _propTypes["default"].object,
  // can be used to turn prop(s) on/off based of on view, f.e. stop/start video/sound
  toggleChildPropsOnInView: _propTypes["default"].bool,
  // can be used to track elements coming into view
  onInView: _propTypes["default"].func,
  onNotInView: _propTypes["default"].func,
  repeatOnInView: _propTypes["default"].bool,
  // whether to run any scroll monintoring at all;
  // because easier to toggle this prop, then toggle not using the component at all.
  useInviewMonitor: _propTypes["default"].func,
  intoViewMargin: _propTypes["default"].string,
  threshold: _propTypes["default"].number
};
InviewMonitor.defaultProps = {
  classNameNotInView: '',
  childPropsNotInView: {},
  useInviewMonitor: function useInviewMonitor() {
    return true;
  },
  intoViewMargin: '-20%',
  threshold: 0
};
var _default = InviewMonitor;
exports["default"] = _default;